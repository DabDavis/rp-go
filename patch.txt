diff --git a/engine/core/game.go b/engine/core/game.go
index 3d82a2da9d5f40603fa0d2c109e53f405ee33569..4e326473bfeb912a374d0421a0b20718577167be 100644
--- a/engine/core/game.go
+++ b/engine/core/game.go
@@ -1,44 +1,59 @@
 package core
 
 import (
 	"github.com/hajimehoshi/ebiten/v2"
 	"rp-go/engine/data"
 	"rp-go/engine/ecs"
+	"rp-go/engine/events"
 	"rp-go/engine/scenes/space"
 	"rp-go/engine/systems/camera"
 	"rp-go/engine/systems/debug"
 	"rp-go/engine/systems/input"
 	"rp-go/engine/systems/movement"
 	"rp-go/engine/systems/render"
 	"rp-go/engine/systems/scene"
 )
 
 type GameWorld struct {
 	World  *ecs.World
 	Config data.RenderConfig
 }
 
 func NewGameWorld() *GameWorld {
 	cfg := data.LoadRenderConfig("engine/data/render_config.json")
 	w := ecs.NewWorld()
 
+	// Wire up the typed event bus so systems can coordinate without
+	// direct dependencies. It gets flushed at the end of every update.
+	w.EventBus = events.NewBus()
+
 	// ✅ Scene manager FIRST — it creates entities (ship, camera, planet)
 	sm := &scene.Manager{}
 	w.AddSystem(sm)
 
 	// ✅ Core systems follow in logical order
 	w.AddSystem(&input.System{})
 	w.AddSystem(&movement.System{})
-	w.AddSystem(&camera.System{})
+	w.AddSystem(camera.NewSystem(camera.Config{
+		MinScale: cfg.Viewport.MinScale,
+		MaxScale: cfg.Viewport.MaxScale,
+		ZoomStep: cfg.Viewport.ZoomStep,
+		ZoomLerp: cfg.Viewport.ZoomLerp,
+	}))
 	w.AddSystem(&render.System{})
 	w.AddSystem(&debug.System{})
 
 	// ✅ Start in the space scene
 	sm.QueueScene(&space.Scene{})
 
 	return &GameWorld{World: w, Config: cfg}
 }
 
-func (g *GameWorld) Update() { g.World.Update() }
-func (g *GameWorld) Draw(screen *ebiten.Image) { g.World.Draw(screen) }
+func (g *GameWorld) Update() {
+	g.World.Update()
 
+	if bus, ok := g.World.EventBus.(*events.TypedBus); ok && bus != nil {
+		bus.Flush()
+	}
+}
+func (g *GameWorld) Draw(screen *ebiten.Image) { g.World.Draw(screen) }
diff --git a/engine/data/loader.go b/engine/data/loader.go
index 5f4c5ae130c4ee5df052ead663e93203ff8f64e8..4fc4f29ff43d5b7dd508fd15a121c4a29d756348 100644
--- a/engine/data/loader.go
+++ b/engine/data/loader.go
@@ -1,44 +1,47 @@
 package data
 
 import (
 	"encoding/json"
 	"os"
 )
 
 type RenderConfig struct {
 	Window struct {
 		Width  int `json:"width"`
 		Height int `json:"height"`
 	} `json:"window"`
 
 	Viewport struct {
-		Width  int     `json:"width"`
-		Height int     `json:"height"`
-		Scale  float64 `json:"scale"`
+		Width    int     `json:"width"`
+		Height   int     `json:"height"`
+		Scale    float64 `json:"scale"`
+		MinScale float64 `json:"min_scale"`
+		MaxScale float64 `json:"max_scale"`
+		ZoomStep float64 `json:"zoom_step"`
+		ZoomLerp float64 `json:"zoom_lerp"`
 	} `json:"viewport"`
 
 	Player struct {
 		SpriteWidth  int     `json:"sprite_width"`
 		SpriteHeight int     `json:"sprite_height"`
 		Scale        float64 `json:"scale"`
 	} `json:"player"`
 
 	Terrain struct {
 		TileSize int     `json:"tile_size"`
 		Scale    float64 `json:"scale"`
 	} `json:"terrain"`
 }
 
 // LoadRenderConfig reads and parses the JSON config file.
 func LoadRenderConfig(path string) RenderConfig {
 	data, err := os.ReadFile(path)
 	if err != nil {
 		panic(err)
 	}
 	var cfg RenderConfig
 	if err := json.Unmarshal(data, &cfg); err != nil {
 		panic(err)
 	}
 	return cfg
 }
-
diff --git a/engine/data/render_config.json b/engine/data/render_config.json
index cab44ab9bcd5de48bc7619377fecb3cba9f39d3d..0a8dcbf827e7ca8edef985da509c2845a85fc047 100644
--- a/engine/data/render_config.json
+++ b/engine/data/render_config.json
@@ -1,7 +1,15 @@
 {
   "window": { "width": 960, "height": 720 },
-  "viewport": { "width": 960, "height": 720, "scale": 5 },
+  "viewport": {
+    "width": 960,
+    "height": 720,
+    "scale": 1.5,
+    "min_scale": 0.5,
+    "max_scale": 3,
+    "zoom_step": 0.1,
+    "zoom_lerp": 0.2
+  },
   "player": { "sprite_width": 1024, "sprite_height": 1024, "scale": 0.025 },
   "terrain": { "tile_size": 32, "scale": 1 }
 }
 
diff --git a/engine/ecs/components.go b/engine/ecs/components.go
index 7766f1dbdebe7b6bb140279de8b8ba11e1cd3578..35ac0f9509cb4bcfe4f8e764390bcc8758fa1cd6 100644
--- a/engine/ecs/components.go
+++ b/engine/ecs/components.go
@@ -1,37 +1,46 @@
 package ecs
 
 import "github.com/hajimehoshi/ebiten/v2"
 
 type Position struct{ X, Y float64 }
+
 func (p *Position) Name() string { return "Position" }
 
 type Velocity struct{ VX, VY float64 }
+
 func (v *Velocity) Name() string { return "Velocity" }
 
 type Sprite struct {
-	Image  *ebiten.Image
-	Width  int
-	Height int
+	Image    *ebiten.Image
+	Width    int
+	Height   int
 	Rotation float64
 }
+
 func (s *Sprite) Name() string { return "Sprite" }
 
 type Camera struct {
-	X, Y   float64
-	Scale  float64
-	Rotation float64
-	Target *Entity
+	X, Y         float64
+	Scale        float64
+	Rotation     float64
+	Target       *Entity
+	TargetScale  float64
+	MinScale     float64
+	MaxScale     float64
+	DefaultScale float64
 }
+
 func (c *Camera) Name() string { return "Camera" }
 
 type CameraTarget struct{}
+
 func (c *CameraTarget) Name() string { return "CameraTarget" }
 
 // Actor defines metadata for players, NPCs, hostiles, and ships.
 type Actor struct {
 	ID         string // logical ID (e.g., "player", "npc_guard")
 	Archetype  string // "player", "npc", "enemy", "ship"
 	Persistent bool   // whether to keep across scene transitions
 }
-func (a *Actor) Name() string { return "Actor" }
 
+func (a *Actor) Name() string { return "Actor" }
diff --git a/engine/gfx/loader.go b/engine/gfx/loader.go
index 2bcc560ec1775aae48b9b2d347a915b0b37322c7..d2a812b2d26eea74264a81184d08024e975ce58c 100644
--- a/engine/gfx/loader.go
+++ b/engine/gfx/loader.go
@@ -1,28 +1,68 @@
 package gfx
 
 import (
 	"fmt"
 	"image"
 	_ "image/png"
 	"os"
+	"sync"
 
 	"github.com/hajimehoshi/ebiten/v2"
 )
 
+type cachedImage struct {
+	once sync.Once
+	img  *ebiten.Image
+	err  error
+}
+
+var imageCache sync.Map // map[string]*cachedImage
+
+// LoadImage returns an Ebiten image, caching decoded results so repeated
+// requests (even across goroutines) reuse the same GPU resource.
 func LoadImage(path string) *ebiten.Image {
+	entryAny, _ := imageCache.LoadOrStore(path, &cachedImage{})
+	entry := entryAny.(*cachedImage)
+
+	entry.once.Do(func() {
+		entry.img, entry.err = decodeImage(path)
+		if entry.err != nil {
+			fmt.Printf("[GFX] Failed to load image: %s (%v)\n", path, entry.err)
+		}
+	})
+
+	if entry.err != nil {
+		return nil
+	}
+	return entry.img
+}
+
+// PreloadImages eagerly loads a list of image paths using a worker-per-path
+// fan-out. It reuses the LoadImage cache so subsequent calls are instantaneous.
+func PreloadImages(paths ...string) {
+	var wg sync.WaitGroup
+	wg.Add(len(paths))
+	for _, path := range paths {
+		path := path
+		go func() {
+			defer wg.Done()
+			LoadImage(path)
+		}()
+	}
+	wg.Wait()
+}
+
+func decodeImage(path string) (*ebiten.Image, error) {
 	file, err := os.Open(path)
 	if err != nil {
-		fmt.Printf("[GFX] Failed to open image: %s (%v)\n", path, err)
-		return nil
+		return nil, err
 	}
 	defer file.Close()
 
 	img, _, err := image.Decode(file)
 	if err != nil {
-		fmt.Printf("[GFX] Failed to decode image: %s (%v)\n", path, err)
-		return nil
+		return nil, err
 	}
 
-	return ebiten.NewImageFromImage(img)
+	return ebiten.NewImageFromImage(img), nil
 }
-
diff --git a/engine/scenes/space/scene.go b/engine/scenes/space/scene.go
index 99cb0fa82af3138abd0972081ab11cd5d61b63f3..a410939deb2ba648b2f876cec42d9a8e937e38dd 100644
--- a/engine/scenes/space/scene.go
+++ b/engine/scenes/space/scene.go
@@ -1,63 +1,67 @@
 package space
 
 import (
 	"fmt"
 	"image/color"
 
 	"github.com/hajimehoshi/ebiten/v2"
 	"rp-go/engine/ecs"
 	"rp-go/engine/gfx"
 )
 
 type Scene struct{ initialized bool }
 
 func (s *Scene) Name() string { return "space" }
 
 func (s *Scene) Init(w *ecs.World) {
 	if s.initialized {
 		return
 	}
 	s.initialized = true
 
 	fmt.Println("[SCENE] Initializing: Space")
 
+	// Warm the texture cache so the first frame doesn't block on disk IO.
+	gfx.PreloadImages(
+		"assets/entities/ship.png",
+		"assets/entities/planet.png",
+	)
+
 	// === Player Ship ===
 	ship := w.NewEntity()
 	ship.Add(&ecs.Actor{
 		ID:         "player",
 		Archetype:  "ship",
 		Persistent: true,
 	})
 	ship.Add(&ecs.Position{X: 100, Y: 100})
 	ship.Add(&ecs.Velocity{})
 	ship.Add(&ecs.CameraTarget{})
 
 	shipImg := gfx.LoadImage("assets/entities/ship.png")
 	ship.Add(&ecs.Sprite{Image: shipImg, Width: 64, Height: 64})
 
 	// === Camera ===
 	cam := w.NewEntity()
 	camComp := &ecs.Camera{X: 100, Y: 100, Scale: 1.5, Target: ship}
 	cam.Add(camComp)
 	fmt.Printf("[SCENE] ✅ Camera entity created (ID %d) → %+v\n", cam.ID, *camComp)
 
 	// === Planet ===
 	planet := w.NewEntity()
 	planet.Add(&ecs.Position{X: 350, Y: 180})
 	planetImg := gfx.LoadImage("assets/entities/planet.png")
 	planet.Add(&ecs.Sprite{Image: planetImg, Width: 128, Height: 128})
 	fmt.Printf("[SCENE] ✅ Planet entity created (ID %d)\n", planet.ID)
 }
 
-
 func (s *Scene) Update(w *ecs.World) {}
 
 func (s *Scene) Draw(w *ecs.World, screen *ebiten.Image) {
 	// ✅ Proper background fill
 	screen.Fill(color.RGBA{0, 0, 32, 255})
 }
 
 func (s *Scene) Unload(w *ecs.World) {
 	fmt.Println("[SCENE] Unloading: Space")
 }
-
diff --git a/engine/systems/camera/system.go b/engine/systems/camera/system.go
index 6dfebf32d9b196acbf3a585f6a4b475596bf542f..855ebf5cc99b0bb1939ec7f1fd56345cf9bc0e35 100644
--- a/engine/systems/camera/system.go
+++ b/engine/systems/camera/system.go
@@ -1,62 +1,166 @@
 package camera
 
 import (
 	"math"
 
 	"github.com/hajimehoshi/ebiten/v2"
+	"github.com/hajimehoshi/ebiten/v2/inpututil"
+
 	"rp-go/engine/ecs"
+	"rp-go/engine/events"
 )
 
-type System struct{}
+// Config controls runtime camera zoom limits and responsiveness.
+type Config struct {
+	MinScale float64
+	MaxScale float64
+	ZoomStep float64
+	ZoomLerp float64
+}
+
+func (c Config) normalized() Config {
+	if c.MinScale <= 0 {
+		c.MinScale = 0.5
+	}
+	if c.MaxScale <= 0 {
+		c.MaxScale = 3
+	}
+	if c.MaxScale < c.MinScale {
+		c.MaxScale = c.MinScale
+	}
+	if c.ZoomStep <= 0 {
+		c.ZoomStep = 0.1
+	}
+	if c.ZoomLerp < 0 {
+		c.ZoomLerp = 0
+	}
+	return c
+}
+
+type System struct {
+	cfg        Config
+	subscribed bool
+}
+
+func NewSystem(cfg Config) *System {
+	return &System{cfg: cfg.normalized()}
+}
 
 func (s *System) Update(w *ecs.World) {
 	var cam *ecs.Camera
 	var target *ecs.Position
 	var targetSprite *ecs.Sprite
 
 	for _, e := range w.Entities {
 		if c, ok := e.Get("Camera").(*ecs.Camera); ok {
 			cam = c
 		}
 		if e.Has("CameraTarget") {
 			if pos, ok := e.Get("Position").(*ecs.Position); ok {
 				target = pos
 			}
 			if spr, ok := e.Get("Sprite").(*ecs.Sprite); ok {
 				targetSprite = spr
 			}
 		}
 	}
 
 	if cam == nil || target == nil {
 		return
 	}
 
+	// One-time wiring for zoom events.
+	if !s.subscribed {
+		if bus, ok := w.EventBus.(*events.TypedBus); ok && bus != nil {
+			events.Subscribe(bus, func(ev events.CameraZoomEvent) {
+				cam.TargetScale = clamp(ev.NewScale, cam.MinScale, cam.MaxScale)
+			})
+			s.subscribed = true
+		}
+	}
+
+	// Ensure the camera carries sane zoom limits and defaults.
+	if cam.MinScale <= 0 {
+		cam.MinScale = s.cfg.MinScale
+	}
+	if cam.MaxScale <= 0 {
+		cam.MaxScale = s.cfg.MaxScale
+	}
+	if cam.MaxScale < cam.MinScale {
+		cam.MaxScale = cam.MinScale
+	}
+	if cam.DefaultScale <= 0 {
+		cam.DefaultScale = clamp(cam.Scale, cam.MinScale, cam.MaxScale)
+	}
+	if cam.TargetScale <= 0 {
+		cam.TargetScale = clamp(cam.Scale, cam.MinScale, cam.MaxScale)
+	} else {
+		cam.TargetScale = clamp(cam.TargetScale, cam.MinScale, cam.MaxScale)
+	}
+
+	// Handle zoom input (keyboard + mouse wheel).
+	zoomDelta := 0.0
+	if inpututil.IsKeyJustPressed(ebiten.KeyMinus) || inpututil.IsKeyJustPressed(ebiten.KeyKPSubtract) {
+		zoomDelta -= s.cfg.ZoomStep
+	}
+	if inpututil.IsKeyJustPressed(ebiten.KeyEqual) || inpututil.IsKeyJustPressed(ebiten.KeyKPAdd) {
+		zoomDelta += s.cfg.ZoomStep
+	}
+	if inpututil.IsKeyJustPressed(ebiten.Key0) || inpututil.IsKeyJustPressed(ebiten.KeyKP0) {
+		cam.TargetScale = clamp(cam.DefaultScale, cam.MinScale, cam.MaxScale)
+	}
+	_, wheelY := ebiten.Wheel()
+	if wheelY != 0 {
+		zoomDelta += wheelY * s.cfg.ZoomStep
+	}
+	if zoomDelta != 0 {
+		cam.TargetScale = clamp(cam.TargetScale+zoomDelta, cam.MinScale, cam.MaxScale)
+	}
+
 	// Smooth follow
 	cam.X += (target.X - cam.X) * 0.1
 	cam.Y += (target.Y - cam.Y) * 0.1
 
+	// Smooth zoom
+	if s.cfg.ZoomLerp <= 0 {
+		cam.Scale = cam.TargetScale
+	} else {
+		cam.Scale += (cam.TargetScale - cam.Scale) * math.Min(1, s.cfg.ZoomLerp)
+		if math.Abs(cam.Scale-cam.TargetScale) < 1e-4 {
+			cam.Scale = cam.TargetScale
+		}
+	}
+
 	// Manual rotation (Q / E)
 	const rotSpeed = 0.03
 	if ebiten.IsKeyPressed(ebiten.KeyQ) {
 		cam.Rotation -= rotSpeed
 	}
 	if ebiten.IsKeyPressed(ebiten.KeyE) {
 		cam.Rotation += rotSpeed
 	}
 
 	// Sync player sprite rotation to camera
 	if targetSprite != nil {
 		targetSprite.Rotation = cam.Rotation
 	}
 
 	// Normalize rotation
 	if cam.Rotation > math.Pi*2 {
 		cam.Rotation -= math.Pi * 2
 	} else if cam.Rotation < 0 {
 		cam.Rotation += math.Pi * 2
 	}
 }
 
 func (s *System) Draw(*ecs.World, *ebiten.Image) {}
 
+func clamp(v, min, max float64) float64 {
+	if v < min {
+		return min
+	}
+	if v > max {
+		return max
+	}
+	return v
+}
diff --git a/engine/systems/debug/debug_camera.go b/engine/systems/debug/debug_camera.go
index e27d8f769c36eff4a04330f87a12e6762140a61a..9198207eab35cab57b43352d14061dfb5accf9ed 100644
--- a/engine/systems/debug/debug_camera.go
+++ b/engine/systems/debug/debug_camera.go
@@ -3,34 +3,46 @@ package debug
 import (
 	"fmt"
 	"image/color"
 
 	"github.com/hajimehoshi/ebiten/v2"
 	"github.com/hajimehoshi/ebiten/v2/text"
 	"golang.org/x/image/font/basicfont"
 	"rp-go/engine/ecs"
 )
 
 func DrawCameraInfo(w *ecs.World, screen *ebiten.Image) {
 	var cam *ecs.Camera
 	for _, e := range w.Entities {
 		if c, ok := e.Get("Camera").(*ecs.Camera); ok {
 			cam = c
 			break
 		}
 	}
 
 	if cam == nil {
 		return
 	}
 
 	sw := float64(screen.Bounds().Dx())
 	sh := float64(screen.Bounds().Dy())
-	
+
+	minScale := cam.MinScale
+	if minScale <= 0 {
+		minScale = cam.Scale
+	}
+	maxScale := cam.MaxScale
+	if maxScale <= 0 {
+		maxScale = cam.Scale
+	}
+	targetScale := cam.TargetScale
+	if targetScale <= 0 {
+		targetScale = cam.Scale
+	}
+
 	msg := fmt.Sprintf(
-	"Camera: (%.1f, %.1f)\nScale: %.2f (%.1f–%.1f)\nViewport: %.0fx%.0f\n",
-	cam.X, cam.Y, cam.Scale, 0.5, 3.0, sw, sh,
+		"Camera: (%.1f, %.1f)\nScale: %.2f → %.2f\nBounds: %.2f–%.2f\nViewport: %.0fx%.0f\n",
+		cam.X, cam.Y, cam.Scale, targetScale, minScale, maxScale, sw, sh,
 	)
 
 	text.Draw(screen, msg, basicfont.Face7x13, 10, 20, color.White)
 }
-
diff --git a/engine/systems/debug/system.go b/engine/systems/debug/system.go
index 53fd2a3d648b8177e8c94e80f979647351ae8f5b..181f033e2ce56920f07124b5c112a819b0c1e584 100644
--- a/engine/systems/debug/system.go
+++ b/engine/systems/debug/system.go
@@ -1,33 +1,57 @@
 package debug
 
 import (
 	"fmt"
 	"image/color"
+	"strings"
 
 	"github.com/hajimehoshi/ebiten/v2"
 	"github.com/hajimehoshi/ebiten/v2/text"
 	"golang.org/x/image/font/basicfont"
 	"rp-go/engine/ecs"
 )
 
 type System struct{}
 
 func (s *System) Update(*ecs.World) {}
 
 func (s *System) Draw(w *ecs.World, screen *ebiten.Image) {
 	var cam *ecs.Camera
 	for _, e := range w.Entities {
 		if c, ok := e.Get("Camera").(*ecs.Camera); ok {
 			cam = c
 			break
 		}
 	}
 
-	msg := fmt.Sprintf("FPS: %.0f\nEntities: %d", ebiten.ActualFPS(), len(w.Entities))
+	var builder strings.Builder
+	builder.WriteString(fmt.Sprintf("FPS: %.0f\nEntities: %d", ebiten.ActualFPS(), len(w.Entities)))
+
 	if cam != nil {
-		msg += fmt.Sprintf("\nCam(%.1f, %.1f) Scale %.2f Rot %.1f°",
-			cam.X, cam.Y, cam.Scale, cam.Rotation*180/3.14159)
+		targetScale := cam.TargetScale
+		if targetScale <= 0 {
+			targetScale = cam.Scale
+		}
+		minScale := cam.MinScale
+		if minScale <= 0 {
+			minScale = cam.Scale
+		}
+		maxScale := cam.MaxScale
+		if maxScale <= 0 {
+			maxScale = cam.Scale
+		}
+		defaultScale := cam.DefaultScale
+		if defaultScale <= 0 {
+			defaultScale = cam.Scale
+		}
+
+		builder.WriteString("\n")
+		builder.WriteString(fmt.Sprintf("Cam: (%.1f, %.1f)\n", cam.X, cam.Y))
+		builder.WriteString(fmt.Sprintf("Rotation: %.1f°\n", cam.Rotation*180/3.14159))
+		builder.WriteString(fmt.Sprintf("Scale: %.2f → %.2f\n", cam.Scale, targetScale))
+		builder.WriteString(fmt.Sprintf("Bounds: %.2f – %.2f\n", minScale, maxScale))
+		builder.WriteString(fmt.Sprintf("Default Scale: %.2f", defaultScale))
 	}
-	text.Draw(screen, msg, basicfont.Face7x13, 10, 20, color.White)
-}
 
+	text.Draw(screen, builder.String(), basicfont.Face7x13, 10, 20, color.White)
+}
diff --git a/engine/systems/scene/system.go b/engine/systems/scene/system.go
index 274d72c362966a87f1959d5f67b6f45fabf40e68..ee2728fd418417c8208581a9f1af54492948eb06 100644
--- a/engine/systems/scene/system.go
+++ b/engine/systems/scene/system.go
@@ -29,39 +29,43 @@ func (m *Manager) Update(w *ecs.World) {
 	}
 
 	// Scene transition
 	if m.next != nil {
 		if m.current != nil {
 			m.current.Unload(w)
 		}
 		m.current = m.next
 		m.next = nil
 		m.current.Init(w)
 		fmt.Printf("[SCENE] Active: %s\n", m.current.Name())
 	}
 
 	if m.current != nil {
 		m.current.Update(w)
 	}
 }
 
 func (m *Manager) Draw(w *ecs.World, screen *ebiten.Image) {
 	if m.current != nil {
 		m.current.Draw(w, screen)
 	}
 }
 
 func (m *Manager) QueueScene(scene ecs.Scene) {
-	if m.current == nil {
-		m.current = scene
-	} else {
-		m.next = scene
+	if scene == nil {
+		return
 	}
+
+	// Always funnel through m.next so the lifecycle consistently
+	// triggers Init/Unload inside Update. The previous implementation
+	// assigned the very first scene straight to m.current, which meant
+	// Init was never called and no entities (camera, player, etc.) were
+	// spawned, leading to the render system spamming "No camera found".
+	m.next = scene
 }
 
 func (m *Manager) currentName() string {
 	if m.current != nil {
 		return m.current.Name()
 	}
 	return "(none)"
 }
-
diff --git a/engine/systems/spawn/system.go b/engine/systems/spawn/system.go
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..1ea6699d028f475c84e1187981933d043b60a646 100644
--- a/engine/systems/spawn/system.go
+++ b/engine/systems/spawn/system.go
@@ -0,0 +1,3 @@
+package spawn
+
+// Placeholder package to keep go tooling happy until the spawn system lands.
diff --git a/engine/world/generator.go b/engine/world/generator.go
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..361e787479d6dafc4227cb59301f6b12ff622d7e 100644
--- a/engine/world/generator.go
+++ b/engine/world/generator.go
@@ -0,0 +1,3 @@
+package world
+
+// Placeholder for future world-generation routines.
diff --git a/engine/world/init.go b/engine/world/init.go
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..16c464c332388a82ad11986625231fa00e3e6c79 100644
--- a/engine/world/init.go
+++ b/engine/world/init.go
@@ -0,0 +1,3 @@
+package world
+
+// TODO: implement world bootstrap wiring here.

